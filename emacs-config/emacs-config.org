#+TITLE: Phil's Emacs Configuration

This configuration integrates with my [[https://github.com/pgroce/emacs-config-framework][configuration framework]], although it could probably be used without it. It also uses some packages from [[https://philgroce.github.io/emacs-pkgs/elpa][my own package repository]].

* Basic environment

** Package configuration

This configuration makes heavy use of Emacs packages, so first, configure the package system.

=use-package= comes with the almost-equally-useful =bind-key= macro, which is much more user-friendly than manipulating keymaps directly.


#+BEGIN_SRC emacs-lisp

  (setq package-archives
        '(("gnu"         . "http://elpa.gnu.org/packages/")
          ("melpa"       . "http://melpa.org/packages/")
          ("pgroce"      . "https://pgroce.github.io/emacs-pkgs/elpa/")
  ))


  (require 'package)
  (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
#+END_SRC

** Foundation packages

I use these packages in lots of places in the configuration, so load them now.

#+BEGIN_SRC emacs-lisp
  (use-package pg-util :ensure t)
  (use-package pg-shell-path :ensure t)
  (use-package pg-ibuffer :ensure t)
#+END_SRC

** Accomodating Emacs customization

Load the output of Emacs' [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Easy-Customization.html][customization]] facility in a sidecar file. I prefer to manually maintain all my configuration, but for some packages it's easier to use =customize= and adapt its output into my config than it is to understand the docs. :/

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "emacs-customize.el") ecfw-config-dir)
  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC


* General configuration

** Unicode
[[https://github.com/rolandwalker/unicode-fonts][unicode-fonts]] does a lot of magic to ensure that you can see as many Unicode glyphs as possible. You have to download several fonts for it to work; check the page for details.

#+BEGIN_SRC emacs-lisp
  (use-package unicode-fonts
    :ensure t
    :config (unicode-fonts-setup))
#+END_SRC

** URLs

See [[https://github.com/pgroce/emacs-pkgs/blob/master/pg-url-armor.org][the library documentation]] for more information on this package.

#+BEGIN_SRC emacs-lisp
  (use-package pg-url-armor :ensure t)
#+END_SRC

Just make it easier to call =browse-url-at-point=

#+BEGIN_SRC emacs-lisp
  (bind-key "s-b" #'browse-url-at-point)
#+END_SRC

** Buffers

*** Unique buffer names

=uniquify= ensures that buffer names are unique, but not ridiculously long. Handy if you're editing the same file in two different source trees, for instance.

#+begin_src emacs-lisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-separator "/")
  (setq uniquify-after-kill-buffer-p t)
  (setq uniquify-ignore-buffers-re "^\\*")
#+end_src

*** Burying buffers

Bury buffers easily.

#+begin_src emacs-lisp
  (bind-key "s-q" #'bury-buffer)
#+end_src

Bury buffers and delete the window they're in. Default behavior from some transient-window-generating modes, but not others. And sometimes you're just done with a window split, darn it.

#+BEGIN_SRC emacs-lisp
  (defun pg/bury-buffer-delete-window ()
    (interactive)
    (bury-buffer)
    (delete-window))

  (bind-key "s-Q" #'pg/bury-buffer-delete-window)
#+END_SRC

***  =ibuffer=

Tweaks to =ibuffer=:

 * Add divisions to =ibuffer-saved-filter-groups= that won't be added elsewhere

=ibuffer-saved-filter-groups= subdivides the =ibuffer= display nicely, but it presents some problems. Notably, it might be nice to conditionally add filtering groups to the display depending on what's loaded. The =pg/add-qualifier-to-ibuffer-filter-group= function allows us to do just that in the custom files. (=temp-shell= and =remote-term= are the names of buffers I create using the functions in [[Temorary Shell]] and [[Remote terminal]].)

=ibuffer-ediff-marked-files= h/t [[http://curiousprogrammer.wordpress.com/2009/04/02/ibuffer/][A Curious Programmer]].


#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind ("C-X C-b" . ibuffer-other-window)
    :init
    (progn
      (setq ibuffer-view-ibuffer t)
      (setq ibuffer-saved-filter-groups
            '(("default" ())))))

    :config
    (progn
      (defun ibuffer-ediff-marked-buffers ()
        (interactive)
        (let* ((marked-buffers (ibuffer-get-marked-buffers))
               (len (length marked-buffers)))
          (unless (= 2 len)
            (error (format "%s buffer%s been marked (needs to be 2)"
                           len (if (= len 1) " has" "s have"))))
          (ediff-buffers (car marked-buffers) (cadr marked-buffers))))

      (add-hook 'ibuffer-mode-hook
                (lambda ()
                  (ibuffer-switch-to-saved-filter-groups "default"))))
#+END_SRC


** Directories (=dired=)

Lots of tweaks to =dired=:

   * Also load =wdired= and =dired+=.
   * Make =M-<= and =M->= do the right thing. (h/t [[http://whattheemacsd.com//setup-dired.el-02.html][What the emacs.d!?]])
   * =z= gets the size of marked files via =du=. (h/t [[http://oremacs.com/2015/01/12/dired-file-size/][(or emacs irrelevant)]])
   * =H= swaps between full and human-readable file sizes.
   * Add =dired= header to =ibuffer=.

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :defer t
    :init
    (progn
      ;; Load dired accessory packages
      (use-package dired+ :ensure t :defer t)
      (use-package wdired
        :defer t
        :init
        (progn
          (setq wdired-allow-to-change-permissions t
                wdired-allow-to-redirect-links t
                wdired-use-interactive-rename t
                wdired-confirm-overwrite t))))

    :config
    (progn
      (defun dired-back-to-top ()
        (interactive)
        (beginning-of-buffer)
        (dired-next-line 4))
      (define-key dired-mode-map
        (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

      (defun dired-jump-to-bottom ()
        (interactive)
        (end-of-buffer)
        (dired-next-line -1))
      (define-key dired-mode-map
        (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)

      (defun dired-get-size ()
        (interactive)
        (let ((files (dired-get-marked-files)))
          (with-temp-buffer
            (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
            (message
             "Size of all marked files: %s"
             (progn
               (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
               (match-string 1))))))
      (bind-key "Z" #'dired-get-size dired-mode-map)


      (defun dired-toggle-show-human-sizes (&optional arg)
        (interactive)
        (when (not (local-variable-p 'dired-listing-switches))
          (make-local-variable 'dired-listing-switches)
          (setq-local dired-old-listing-switches dired-listing-switches))
        (if (or arg
                (equal dired-listing-switches dired-old-listing-switches))
            (setq dired-listing-switches
                  (concat dired-old-listing-switches "h"))
          (setq dired-listing-switches dired-old-listing-switches))
        (dired-sort-other dired-listing-switches))
      (add-hook 'dired-mode-hook 'dired-toggle-show-human-sizes)
      (bind-key "H" #'dired-toggle-show-human-sizes dired-mode-map)

      (pg-ibuffer '("default" (("dired" . (mode . dired-mode)))))))
#+END_SRC

** Narrowing (=helm=)

[[https://github.com/emacs-helm/helm][Helm]], like =ibuffer=, is a cross-cutting concern. This is the core setup; elsewhere in the config, other packages will customize Helm to their needs.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :defer t
    :ensure t
    :diminish helm-mode
    :init (use-package helm-swoop
            :bind ("M-1" . helm-swoop))
    :config
    (progn
      (require 'helm-config)
      (bind-key "<tab" #'helm-execute-persistent-action helm-map)
      (bind-key "C-i" #'helm-execute-persistent-action helm-map)
      (bind-key "C-z" #'helm-select-action helm-map)
      (bind-key "M-x" #'helm-M-x)
      (bind-key "C-x C-f" #'helm-find-files)
      (helm-mode 1)))
#+END_SRC



** Small things
*** =expand-region=

[[https://github.com/magnars/expand-region.el][expand-region]] expands the existing selection to the next largest semantic unit (character, word, sentence, paragraph; character, word, string, function; etc.) It is useful magic.

I have it bound to =M-2= as part of an ergonomic trifecta of keys: =M-1= is bound to =helm-swoop= and =M-3= is bound to =mc/mark-all-dwim=, so I can select things quickly with =M-2= and quickly either search for them or operate on all instance of them in a file.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("M-2" . er/expand-region))
#+END_SRC

*** =multiple-cursors=

As I said above, bound to =M-3= because I'm just so clever.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind (("M-3" . mc/mark-all-dwim)))
#+END_SRC

*** Kaomoji
The most important part of my configuration file. :) There's probably a way to do this with abbreviations or (gag) YASnippet, but this works and doesn't require much research.

#+BEGIN_SRC emacs-lisp
  (defmacro pg/make-insert-command (cmd-name to-insert)
    `(defun ,cmd-name () (interactive) (insert ,to-insert)))
#+END_SRC

**** =shrug=/=welp=

I guess the canonical name for this is =shrug=.

#+BEGIN_SRC emacs-lisp
  (defun welp ()
    "Insert complicated but hugely important string into buffer."
    (interactive)
    (insert "Â¯\\_(ãƒ„)_/Â¯"))
  (defalias 'shrug 'welp)
#+END_SRC

**** =table-flip=

#+BEGIN_SRC emacs-lisp
  (defun table-flip ()
      "Insert complicated but hugely important string into buffer."
      (interactive)
      (insert "(â•¯Â°â–¡Â°ï¼‰â•¯ï¸µ â”»â”â”»"))
#+END_SRC

**** =eyes=

#+BEGIN_SRC emacs-lisp
  (defun eyes ()
      "Insert complicated but hugely important string into buffer."
      (interactive)
      (insert "ðŸ‘€"))
#+END_SRC


*** One(ish)-liners

Put all backups in one place.

#+begin_src emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backup")))
#+end_src

Inhibit splash screen.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

Never insert tabs.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

Delete trailing white space.

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Substitute "yes/no" prompts with "y/n" prompts.

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Yes, I know it's a large file. Open it anyway.

#+begin_src emacs-lisp
  (setq large-file-warning-threshold nil)
#+end_src

=narrow-to-region= is disabled by default, because the behavior is potentially scary to new users. I use it enough for that to be worth changing.

#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+end_src

When I run =man=, use the frame I'm in when I run it, so I can scroll and whatnot.

#+BEGIN_SRC emacs-lisp
  (setq Man-notify-method 'pushy)
#+END_SRC

Enable [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Window-Convenience.html][winner-mode]].

#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

Make =split-sensibly= split, er, more sensibly

#+BEGIN_SRC emacs-lisp
  ;;; Original value: 80
  (setq split-height-threshold nil)
#+END_SRC

Disable version control on tramp, to speed it up

#+BEGIN_SRC emacs-lisp
  (setq vc-ignore-dir-regexp
        (format "\\(%s\\)\\|\\(%s\\)"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))
#+END_SRC

Save command history and some other variables.

#+BEGIN_SRC emacs-lisp
  (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
  (savehist-mode 1)
#+END_SRC



* General terminal configurations

Emacs extends the notion of the terminal (like xterm or VT-220 terminals) to include the GUI versions that run on GTK, Windows, OS X, etc.

=pg-terminal-config= provides macros we use later to conditionally execute code for different terminals.

#+BEGIN_SRC emacs-lisp
  (use-package pg-terminal :ensure t)
#+END_SRC

Configuration of each terminal is done in [[Customizing platforms]], below.

** GUI Customizations


*** Clean frames

Customize the GUI frame look and feel the way I want it.

#+begin_src emacs-lisp
  (defun pg-clean-frames ()
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (transient-mark-mode -1)
    (setq inhibit-splash-screen t)
    (show-paren-mode 1)
    (column-number-mode)

    (pg-util-alist-update 'window-system-default-frame-alist
                          '((nil (menu-bar-lines . 0)
                                 (tool-bar-lines . 0)))))
#+end_src

*** Navigation

I always bind =super= to the right alt key, so these keybinds are pretty effective ways to quickly travel between windows and frames. Basically just hold down right-alt and move up and down to go between windows, and left and right to go between frames.

#+begin_src emacs-lisp
  (defun pg-prev-frame () (interactive) (other-frame 1))
  (defun pg-next-frame () (interactive) (other-frame -1))

  (defun pg-navigate-frames ()
    (global-set-key (kbd "<s-right>") 'pg-next-frame)
    (global-set-key (kbd "<s-left>") 'pg-prev-frame))

  (defun pg-prev-window () (interactive) (other-window -1))
  (defun pg-next-window () (interactive) (other-window 1))

  (defun pg-navigate-windows ()
    (global-set-key (kbd "<s-up>") 'pg-prev-window)
    (global-set-key (kbd "<s-down>") 'pg-next-window))
#+end_src





** Plain ol' terminal

These changes apply to every terminal-based Emacs I care about.

#+BEGIN_SRC emacs-lisp
  (pg-terminal-t
   (pg-clean-frames)
   (pg-navigate-frames)
   (pg-navigate-windows))
#+END_SRC


* Customizing workflows

** Org mode

[[http://orgmode.org][Org mode]] isn't a specific workflow, but it supports organization, note taking, and literate programming, which I use in many other workflows.

This section contains my core org-mode configuration. There may be additional configuration in subsequent sections (e.g., registering languages with [[http://orgmode.org/worg/org-contrib/babel/][Babel]]).

#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind (("s-o l"   . org-store-link)
           ("s-o RET" . org-open-at-point))

    :init
    (setq
     org-hide-leading-stars t
     org-fast-tag-selection-single-key 'expert

     org-default-notes-file "~/notes.org"

     ;; Allow org-mode to refile deeper in the tree
     org-refile-targets '((nil :maxlevel . 2))
     org-refile-use-outline-path t
     org-outline-path-complete-in-steps nil

     ;; Log all my notes, clock time, etc. related to an item into a
     ;; drawer named LOGBOOK, so it can be collapsed and doesn't clutter
     ;; up the display.
     org-log-into-drawer "LOGBOOK")

    :mode ("\\.org\\'" . (lambda ()
                           (org-mode)
                           (visual-line-mode)))
    :config
    (progn
      (pg-util-diminish-major org-mode "")
      ;; TODO: Is this necessary?
      (add-hook 'org-mode-hook 'turn-on-font-lock)))
#+END_SRC

*** Agenda

A few of the variables configured here really live in =org.el=, but they're relevant to org-mode-as-personal-organizer, which is what =org-agenda= is about anyway.

=org-agenda-custom-commands= controls additional default views I might want on the agenda. I'm cargo-culting much of this, mostly from [[http://newartisans.com/2007/08/using-org-mode-as-a-day-planner/][John Wiegley's seminal GTD configuration]] (where I got a lot of the rest of it, too).


#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :bind (("C-c a" . org-agenda)
           :map org-agenda-mode-map
           ("C-n" . next-line)
           ("C-p" . previous-line))

    :init
    (setq org-agenda-files '("~/todo.org"
                             "~/todo-personal.org")
          org-agenda-ndays 7
          org-deadline-warning-days 14
          org-agenda-show-all-dates t
          org-agenda-skip-deadline-if-done t
          org-agenda-skip-scheduled-if-done t
          org-agenda-start-on-weekday nil
          org-reverse-note-order t

          ;; Control how teh Agenda view sorts tasks
          org-agenda-sorting-strategy
          '((agenda
             habit-down
             priority-down
             alpha-up
             time-up
             category-keep)
            (todo
             priority-down
             category-keep)
            (tags
             priority-down
             category-keep)
            (search category-keep))


          org-agenda-custom-commands
          '(("b" "Backlog items" todo "BACKLOG")
            ("a" "Agenda" agenda ""
             ((org-agenda-skip-function
               (lambda nil
                 (org-agenda-skip-entry-if 'todo '("BACKLOG"))))
              (org-agenda-ndays 7)))
            ("A" "Agenda (with backlog)" agenda ""
             ((org-agenda-skip-function
               (lambda nil
                 (org-agenda-skip-entry-if 'notregexp "\\=.*\\[#A\\]")))
              (org-agenda-ndays 1)
              (org-agenda-overriding-header "Today's Priority #A tasks: ")))
            ("w" todo "WAITING" nil)
            ("W" agenda ""
             ((org-agenda-ndays 21)))

            ("u" alltodo ""
             ((org-agenda-skip-function
               (lambda nil
                 (org-agenda-skip-entry-if 'scheduled
                                           'deadline
                                           'regexp "\n]+>")))
              (org-agenda-overriding-header "Unscheduled TODO entries: ")))))

    :config
    (progn
      (pg-util-diminish-major org-agenda-mode "")))
#+END_SRC

*** Contacts

#+BEGIN_SRC emacs-lisp
  (use-package org-contacts
    :bind (("C-c ?" . org-contacts)
           ("s-/"   . org-contacts))

    :init
    (setq org-contacts-files "~/contacts.org"
          org-contacts-icon-use-gravatar nil))
#+END_SRC

*** Capture

Configuration for [[http://orgmode.org/manual/Capture.html][org-capture]] (formerly =org-remember=).

#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :bind ("s-r" . org-capture)

    :init
    (setq org-capture-templates
          `(("t" "TODO" entry (file+headline "~/todo.org" "Tasks")
             "* TODO %?\n  %u" :prepend t)
            ("T" "TODO (personal)" entry (file+headline
                                          "~/todo-personal.org" "Tasks")
             "* TODO %?\n  %u" :prepend t)
            ("n" "Notes" entry (file+headline "~/notes.org" "Notes")
             "* %u %?" :prepend t)
            ("c" "Contacts" entry (file+headline "~/contacts.org" "New Contacts")
             ,(concat "* %(org-contacts-template-name)\n"
                      ":PROPERTIES:\n"
                      ":EMAIL: %(org-contacts-template-email)\n"
                      ":END:\n")))))
#+END_SRC

*** Indent

#+BEGIN_SRC emacs-lisp
  (use-package org-indent :diminish org-indent-mode)
#+END_SRC




** Text processing

*** Plain Text (=.txt=)

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist
               '("\\.txt$" . (lambda ()
                               (visual-line-mode)
                               (flyspell-mode))))

  (pg-ibuffer '("default" (("text" . (or
                                      (mode . text-mode)
                                      (mode . fundamental-mode)
                                      (mode . visual-line-mode))))))

#+END_SRC



*** TeX/LaTeX

You will obviously need TeX/LaTeX installed on your machine for this to be valuable. (And =texbin= will need to be in =exec-path=. How that happens is platform-specific

Enable previewing of LaTeX files.

#+BEGIN_SRC emacs-lisp
(use-package preview-latex)
#+END_SRC

Make =ibuffer= TeX-aware.

#+BEGIN_SRC emacs-lisp
  (pg-ibuffer '("default" (("TeX" (or
                                   (mode . tex-mode)
                                   (mode . latex-mode))))))
#+END_SRC


*** reStructuredText (=.rst=)

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist
               '("\\.rst$" . (lambda ()
                               (rst-mode)
                               (visual-line-mode)
                               (flyspell-mode))))

  (pg-ibuffer '("default" (("ReST" (mode . rst-mode)))))
#+END_SRC

*** XML and HTML

[[http://www.thaiopensource.com/nxml-mode/][nXML mode]] is marvelous. I use it to edit XML. I used to use it for HTML, too, but now I prefer =sgml-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package nxml-mode
    :mode (("\\.xml$" . nxml-mode))
    :config
    (pg-ibuffer '("default" (("XML" (mode . nxml-mode))))))



  (use-package sgml-mode
    :mode (("\\.html$" . html-mode))
    :config
    (pg-ibuffer '("default" (("HTML" (mode . sgml-mode))))))
#+END_SRC


*** JSON

#+BEGIN_SRC emacs-lisp
  (use-package json-mode :ensure t)
#+END_SRC

*** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md$" . markdown-mode))
    :config
    (progn
      (add-hook 'markdown-mode-hook 'visual-line-mode)))
#+END_SRC



** Programming

*** Compilation buffers

If I click on an error in =*compilation*= and the file is already open in a frame, don't re-open it in a new frame.

#+BEGIN_SRC emacs-lisp
  (setq display-buffer-reuse-frames t)
#+END_SRC

Cycle through compilation buffer-naming strategies (currently the defaultâ€“reuse =*compilation*= everywhereâ€“and creating one compile buffer per buffer in which =compile= was invoked.

#+BEGIN_SRC emacs-lisp
  (use-package pg-compile-buffers :ensure t)
#+END_SRC

*** Auto-completion (=company=)

[[http://company-mode.github.io/][Company mode]] is great. Mostly it's used by other things, so I don't have to configure or enable it, just make sure it's available. (I don't like seeing take up space in the modeline, though, so diminish it to nothing.)

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :commands company-mode
    :diminish "")
#+END_SRC



*** Languages

**** Lisps

Show matching parentheses.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

***** =paredit=

[[http://www.emacswiki.org/emacs/ParEdit][Semantic editing for lisp]].


#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :commands paredit-mode
    :init
    (progn
      (global-set-key (kbd "M-[") 'backward-sexp)
      (global-set-key (kbd "M-]") 'forward-sexp))
    :config (diminish 'paredit-mode " ()"))
#+END_SRC


***** Emacs Lisp

Turn on =auto-completion=, =eldoc= and =paredit=.

#+BEGIN_SRC emacs-lisp
  (use-package lisp-mode
    :init
    (progn
      (add-hook
       'emacs-lisp-mode-hook
       '(lambda ()
          (company-mode)
          (eldoc-mode)
          (paredit-mode)))
      (pg/diminish-major emacs-lisp-mode "elisp")))
#+END_SRC



* Customizing platforms

** OS X

Everything in this section goes in =darwin.el= and gets executed only on OS X systems.

This config pretty much assumes you run [[https://brew.sh/][Homebrew]].

*** General customizations

I don't wrap these in =pg-terminal-ns= because they're OS X-specific, not strictly ns-specific. (I dunno, maybe I'll run this on Gnustep someday.)

**** Use =mdfind= as =locate=

On many Unix systems, the =locate= command will run the system =locate= command to search a pre-compiled file database for a file. On OS X, the =mdfind= command (which searches Spotlight) has sufficiently similar syntax that it can be used instead.

#+BEGIN_SRC emacs-lisp
  (setq locate-command "mdfind")
#+END_SRC

**** GNU =ls=

OS X =ls= is not GNU, so use =gls= (the version of =ls= from GNU Coreutils) on the Mac instead of =/bin/ls=, because the GNU version supports dired better. (Make sure it's installed via MacPorts, Homebrew, etc.)

#+BEGIN_SRC emacs-lisp
  (if (= 0 (shell-command "which gls"))
      (setq insert-directory-program "gls")
    (message "Pro-tip: Install 'gls' ('brew install coreutils') for a better dired experience."))
#+END_SRC


**** Set =TMPDIR= to something short

OS X has horrible long temporary directory paths that sometimes exceed the lengths some applications are expecting. Just use =/tmp=

#+BEGIN_SRC emacs-lisp
  (setenv "TMPDIR" "/tmp")
#+END_SRC


*** =ns= terminal configuration


**** Decontaminate =super= keybindings

The =ns= Emacs port adds a number of keybindings to =super= in an attempt to make Emacs feel like a NeXTStep/Mac application.

I'd rather use the Emacs style of interaction, because I've learned it already and because I can find better uses for =super=. (Most of these bindings are harmless, but a few, like =s-q= running =save-buffers-kill-emacs=, are infuriating.)

Furthermore, I like to put my own bindings on =super=.

Therefore, kill it all with fire.

#+BEGIN_SRC emacs-lisp :tangle darwin.el
  (pg-terminal-ns
   (global-unset-key (kbd "M-s-h"))
   (global-unset-key (kbd "s-,"))
   (global-unset-key (kbd "s-'"))
   (global-unset-key (kbd "s-`"))
   (global-unset-key (kbd "s-~"))
   (global-unset-key (kbd "s--"))
   (global-unset-key (kbd "s-:"))
   (global-unset-key (kbd "s-?"))
   (global-unset-key (kbd "s-^"))
   (global-unset-key (kbd "s-&"))
   (global-unset-key (kbd "s-C"))
   (global-unset-key (kbd "s-D"))
   (global-unset-key (kbd "s-E"))
   (global-unset-key (kbd "s-L"))
   (global-unset-key (kbd "s-M"))
   (global-unset-key (kbd "s-S"))
   (global-unset-key (kbd "s-a"))
   (global-unset-key (kbd "s-c"))
   (global-unset-key (kbd "s-d"))
   (global-unset-key (kbd "s-e"))
   (global-unset-key (kbd "s-f"))
   (global-unset-key (kbd "s-g"))
   (global-unset-key (kbd "s-h"))
   (global-unset-key (kbd "s-H"))
   (global-unset-key (kbd "s-j"))
   (global-unset-key (kbd "s-k"))
   (global-unset-key (kbd "s-l"))
   (global-unset-key (kbd "s-m"))
   (global-unset-key (kbd "s-n"))
   (global-unset-key (kbd "s-o"))
   (global-unset-key (kbd "s-p"))
   (global-unset-key (kbd "s-q"))
   (global-unset-key (kbd "s-s"))
   (global-unset-key (kbd "s-t"))
   (global-unset-key (kbd "s-u"))
   (global-unset-key (kbd "s-v"))
   (global-unset-key (kbd "s-w"))
   (global-unset-key (kbd "s-x"))
   (global-unset-key (kbd "s-y"))
   (global-unset-key (kbd "s-z"))
   (global-unset-key (kbd "s-|"))
   (global-unset-key (kbd "s-<kp-bar>"))
   (global-unset-key (kbd "s-<right>"))
   (global-unset-key (kbd "s-<left>")))
#+END_SRC

**** GUI setup

Use the navigation functions defined in the general configuration in OS X GUI Emacs.

#+BEGIN_SRC emacs-lisp :tangle darwin.el
  (pg-terminal-ns
   (pg-clean-frames)
   (pg-navigate-frames)
   (pg-navigate-windows))
#+END_SRC

**** Keyboard/mouse setup

***** Modifier keys

Make left command =meta=, and make right alt and right command =super=. (I should experiment with right command being =hyper=, but haven't so far.)

#+BEGIN_SRC emacs-lisp :tangle darwin.el

  (pg-terminal-ns
   (setq ns-right-control-modifier 'super)
   (setq ns-option-modifier  nil)
   (setq ns-right-option-modifier  'super)
   (setq ns-command-modifier 'meta))
#+END_SRC

***** Restore mouse wheel

The mouse wheel setup will get clobbered when using a daemon, due to the different order in which things start up. This restores it.

#+begin_src emacs-lisp :tangle darwin.el
  (pg-terminal-ns
   (when (daemonp)
     (progn
       (setq-default mouse-wheel-down-event 'wheel-up
                     mouse-wheel-up-event 'wheel-down)
       (global-set-key (kbd "<wheel-up>") 'mwheel-scroll)
       (global-set-key (kbd "<wheel-down>") 'mwheel-scroll))))
#+end_src




* Integrations with external tools

** =pdf-tools=

#+BEGIN_SRC emacs-lisp :tangle darwin.el
  (if (= 0 (shell-command "which epdfinfo"))
      (use-package pdf-tools :ensure t)
    (message "Pro-tip: Install pdf-tools (e.g., 'brew install pdf-tools') for better PDF experience."))
#+END_SRC


** LaTeX

#+BEGIN_SRC emacs-lisp :tangle darwin.el
  (if (file-exists-p "/Library/TeX/texbin")
      (pg-shell-path-append "/Library/Tex/texbin")
    (message "Pro-tip: Install Tex (or MacTeX) for a better LaTeX experience"))
#+END_SRC

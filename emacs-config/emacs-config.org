#+TITLE: Phil's Emacs Configuration

This configuration integrates with my [[https://github.com/pgroce/emacs-config-framework][configuration framework]], although it could probably be used without it. It also uses some packages from [[https://philgroce.github.io/emacs-pkgs/elpa][my own package repository]].

* Basic environment

** Package configuration

This configuration makes heavy use of Emacs packages, so first, configure the package system.

=use-package= comes with the almost-equally-useful =bind-key= macro, which is much more user-friendly than manipulating keymaps directly.


#+BEGIN_SRC emacs-lisp

  (setq package-archives
        '(("gnu"         . "http://elpa.gnu.org/packages/")
          ("melpa"       . "http://melpa.org/packages/")
          ("pgroce"      . "https://pgroce.github.io/emacs-pkgs/elpa/")
  ))


  (require 'package)
  (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
#+END_SRC

** Foundation packages

I use these packages in lots of places in the configuration, so load them now.

#+BEGIN_SRC emacs-lisp
  (use-package pg-util :ensure t)
  (use-package pg-shell-path :ensure t)
  (use-package pg-ibuffer :ensure t)
#+END_SRC

** Accomodating Emacs customization

Load the output of Emacs' [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Easy-Customization.html][customization]] facility in a sidecar file. I prefer to manually maintain all my configuration, but for some packages it's easier to use =customize= and adapt its output into my config than it is to understand the docs. :/

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "emacs-customize.el" ecfw-config-dir))
  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC


* General configuration

** Unicode
[[https://github.com/rolandwalker/unicode-fonts][unicode-fonts]] does a lot of magic to ensure that you can see as many Unicode glyphs as possible. You have to download several fonts for it to work; check the page for details.

#+BEGIN_SRC emacs-lisp
  (use-package unicode-fonts
    :ensure t
    :config (unicode-fonts-setup))
#+END_SRC

** URLs

See [[https://github.com/pgroce/emacs-pkgs/blob/master/pg-url-armor.org][the library documentation]] for more information on this package.

#+BEGIN_SRC emacs-lisp
  (use-package pg-url-armor :ensure t)
#+END_SRC

Just make it easier to call =browse-url-at-point=

#+BEGIN_SRC emacs-lisp
  (bind-key "s-b" #'browse-url-at-point)
#+END_SRC

** Buffers

*** Unique buffer names

=uniquify= ensures that buffer names are unique, but not ridiculously long. Handy if you're editing the same file in two different source trees, for instance.

#+begin_src emacs-lisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-separator "/")
  (setq uniquify-after-kill-buffer-p t)
  (setq uniquify-ignore-buffers-re "^\\*")
#+end_src

*** Burying buffers

Bury buffers easily.

#+begin_src emacs-lisp
  (bind-key "s-q" #'bury-buffer)
#+end_src

Bury buffers and delete the window they're in. Default behavior from some transient-window-generating modes, but not others. And sometimes you're just done with a window split, darn it.

#+BEGIN_SRC emacs-lisp
  (defun pg-bury-buffer-delete-window ()
    (interactive)
    (bury-buffer)
    (delete-window))

  (bind-key "s-Q" #'pg-bury-buffer-delete-window)
#+END_SRC

***  =ibuffer=

Tweaks to =ibuffer=:

 * Add divisions to =ibuffer-saved-filter-groups= that won't be added elsewhere

=ibuffer-ediff-marked-files= h/t [[http://curiousprogrammer.wordpress.com/2009/04/02/ibuffer/][A Curious Programmer]].


#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind ("C-X C-b" . ibuffer-other-window)
    :init
    (progn
      (setq ibuffer-view-ibuffer t)
      (setq ibuffer-saved-filter-groups
            '(("default" ())))))

    :config
    (progn
      (defun ibuffer-ediff-marked-buffers ()
        (interactive)
        (let* ((marked-buffers (ibuffer-get-marked-buffers))
               (len (length marked-buffers)))
          (unless (= 2 len)
            (error (format "%s buffer%s been marked (needs to be 2)"
                           len (if (= len 1) " has" "s have"))))
          (ediff-buffers (car marked-buffers) (cadr marked-buffers))))

      (add-hook 'ibuffer-mode-hook
                (lambda ()
                  (ibuffer-switch-to-saved-filter-groups "default"))))
#+END_SRC


** Directories (=dired=)

Lots of tweaks to =dired=:

   * Also load =wdired= and =dired+=.
   * Make =M-<= and =M->= do the right thing. (h/t [[http://whattheemacsd.com//setup-dired.el-02.html][What the emacs.d!?]])
   * =z= gets the size of marked files via =du=. (h/t [[http://oremacs.com/2015/01/12/dired-file-size/][(or emacs irrelevant)]])
   * =H= swaps between full and human-readable file sizes.
   * Add =dired= header to =ibuffer=.

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :defer t
    :init
    (progn
      ;; Load dired accessory packages
      (use-package dired+ :ensure t :defer t)
      (use-package wdired
        :defer t
        :init
        (progn
          (setq wdired-allow-to-change-permissions t
                wdired-allow-to-redirect-links t
                wdired-use-interactive-rename t
                wdired-confirm-overwrite t))))

    :config
    (progn
      (defun dired-back-to-top ()
        (interactive)
        (beginning-of-buffer)
        (dired-next-line 4))
      (define-key dired-mode-map
        (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

      (defun dired-jump-to-bottom ()
        (interactive)
        (end-of-buffer)
        (dired-next-line -1))
      (define-key dired-mode-map
        (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)

      (defun dired-get-size ()
        (interactive)
        (let ((files (dired-get-marked-files)))
          (with-temp-buffer
            (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
            (message
             "Size of all marked files: %s"
             (progn
               (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
               (match-string 1))))))
      (bind-key "Z" #'dired-get-size dired-mode-map)


      (defun dired-toggle-show-human-sizes (&optional arg)
        (interactive)
        (when (not (local-variable-p 'dired-listing-switches))
          (make-local-variable 'dired-listing-switches)
          (setq-local dired-old-listing-switches dired-listing-switches))
        (if (or arg
                (equal dired-listing-switches dired-old-listing-switches))
            (setq dired-listing-switches
                  (concat dired-old-listing-switches "h"))
          (setq dired-listing-switches dired-old-listing-switches))
        (dired-sort-other dired-listing-switches))
      (add-hook 'dired-mode-hook 'dired-toggle-show-human-sizes)
      (bind-key "H" #'dired-toggle-show-human-sizes dired-mode-map)

      (pg-ibuffer '("default" (("dired" . (mode . dired-mode)))))))
#+END_SRC

** Remote editing (=tramp=)

This bit of voodoo allows me to edit files on remote machines as =root=.

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :init
    (progn
      (setq tramp-default-method "ssh")
      ;; Allow sudo to root on remote machines
      (setq tramp-default-proxies-alist '())
      (add-to-list 'tramp-default-proxies-alist
                   '(nil "\\`root\\'" "/ssh:%h:"))
      (add-to-list 'tramp-default-proxies-alist
                   '((regexp-quote (system-name)) nil nil))))
#+END_SRC

** Narrowing (=helm=)

[[https://github.com/emacs-helm/helm][Helm]], like =ibuffer=, is a cross-cutting concern. This is the core setup; elsewhere in the config, other packages will customize Helm to their needs.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :defer t
    :ensure t
    :diminish helm-mode
    :bind (("M-x" . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("C-x b" . helm-buffers-list)
           ("M-y" . helm-show-kill-ring)
           ("C-h a" . helm-apropos)
           :map helm-map
           ("<tab>" . helm-execute-persistent-action)
           ("C-i"   . helm-execute-persistent-action)
           ("C-z"   . helm-select-action)
           )
    :init
    (progn
      (helm-mode 1)

      (use-package helm-swoop
        :ensure t
        :bind ("M-1" . helm-swoop))

      (use-package helm-descbinds
        :ensure t
        :bind ("C-h b" . helm-descbinds))))
#+END_SRC


** Printing

Some very basic printing defaults.

#+begin_src emacs-lisp
(setq ps-print-color-p 'black-white)
(setq-default ps-default-fg "black")
(setq-default ps-default-bg "white")
#+end_src

** Small things
*** =expand-region=

[[https://github.com/magnars/expand-region.el][expand-region]] expands the existing selection to the next largest semantic unit (character, word, sentence, paragraph; character, word, string, function; etc.) It is useful magic.

I have it bound to =M-2= as part of an ergonomic trifecta of keys: =M-1= is bound to =helm-swoop= and =M-3= is bound to =mc/mark-all-dwim=, so I can select things quickly with =M-2= and quickly either search for them or operate on all instance of them in a file.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("M-2" . er/expand-region))
#+END_SRC

*** =multiple-cursors=

As I said above, bound to =M-3= because I'm just so clever.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind (("M-3" . mc/mark-all-dwim)))
#+END_SRC

*** Kaomoji
The most important part of my configuration file. :) There's probably a way to do this with abbreviations or (gag) YASnippet, but this works and doesn't require much research.

#+BEGIN_SRC emacs-lisp
  (defmacro pg/make-insert-command (cmd-name to-insert)
    `(defun ,cmd-name () (interactive) (insert ,to-insert)))
#+END_SRC

**** =shrug=/=welp=

I guess the canonical name for this is =shrug=.

#+BEGIN_SRC emacs-lisp
  (defun welp ()
    "Insert complicated but hugely important string into buffer."
    (interactive)
    (insert "¬Ø\\_(„ÉÑ)_/¬Ø"))
  (defalias 'shrug 'welp)
#+END_SRC

**** =table-flip=

#+BEGIN_SRC emacs-lisp
  (defun table-flip ()
      "Insert complicated but hugely important string into buffer."
      (interactive)
      (insert "(‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª"))
#+END_SRC

**** =eyes=

#+BEGIN_SRC emacs-lisp
  (defun eyes ()
      "Insert complicated but hugely important string into buffer."
      (interactive)
      (insert "üëÄ"))
#+END_SRC


*** One(ish)-liners

Put all backups in one place.

#+begin_src emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backup")))
#+end_src

Inhibit splash screen.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

Never insert tabs.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

Delete trailing white space.

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Substitute "yes/no" prompts with "y/n" prompts.

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Yes, I know it's a large file. Open it anyway.

#+begin_src emacs-lisp
  (setq large-file-warning-threshold nil)
#+end_src

=narrow-to-region= is disabled by default, because the behavior is potentially scary to new users. I use it enough for that to be worth changing.

#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+end_src

When I run =man=, use the frame I'm in when I run it, so I can scroll and whatnot.

#+BEGIN_SRC emacs-lisp
  (setq Man-notify-method 'pushy)
#+END_SRC

Enable [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Window-Convenience.html][winner-mode]].

#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

Make =split-sensibly= split, er, more sensibly

#+BEGIN_SRC emacs-lisp
  ;;; Original value: 80
  (setq split-height-threshold nil)
#+END_SRC

Disable version control on tramp, to speed it up

#+BEGIN_SRC emacs-lisp
  (setq vc-ignore-dir-regexp
        (format "\\(%s\\)\\|\\(%s\\)"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))
#+END_SRC

Save command history and some other variables.

#+BEGIN_SRC emacs-lisp
  (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
  (savehist-mode 1)
#+END_SRC



* General terminal configurations

Emacs extends the notion of the terminal (like xterm or VT-220 terminals) to include the GUI versions that run on GTK, Windows, OS X, etc.

=pg-terminal-config= provides macros we use later to conditionally execute code for different terminals.

#+BEGIN_SRC emacs-lisp
  (use-package pg-terminal :ensure t)
#+END_SRC

Configuration of each terminal is done in [[Customizing platforms]], below.

** GUI Customizations


*** Clean frames

Customize the GUI frame look and feel the way I want it.

#+begin_src emacs-lisp
  (defun pg-clean-frames ()
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (transient-mark-mode -1)
    (setq inhibit-splash-screen t)
    (show-paren-mode 1)
    (column-number-mode)

    (pg-util-alist-update-var 'window-system-default-frame-alist
                              '((nil (menu-bar-lines . 0)
                                     (tool-bar-lines . 0)))))
#+end_src

*** Navigation

I always bind =super= to the right alt key, so these keybinds are pretty effective ways to quickly travel between windows and frames. Basically just hold down right-alt and move up and down to go between windows, and left and right to go between frames.

#+begin_src emacs-lisp
  (defun pg-prev-frame () (interactive) (other-frame 1))
  (defun pg-next-frame () (interactive) (other-frame -1))

  (defun pg-navigate-frames ()
    (global-set-key (kbd "<s-right>") 'pg-next-frame)
    (global-set-key (kbd "<s-left>") 'pg-prev-frame))

  (defun pg-prev-window () (interactive) (other-window -1))
  (defun pg-next-window () (interactive) (other-window 1))

  (defun pg-navigate-windows ()
    (global-set-key (kbd "<s-up>") 'pg-prev-window)
    (global-set-key (kbd "<s-down>") 'pg-next-window))
#+end_src





** Plain ol' terminal

These changes apply to every terminal-based Emacs I care about.

#+BEGIN_SRC emacs-lisp
  (pg-terminal-t
   (pg-clean-frames)
   (pg-navigate-frames)
   (pg-navigate-windows))
#+END_SRC


* Customizing workflows

** Org mode

[[http://orgmode.org][Org mode]] isn't a specific workflow, but it supports organization, note taking, and literate programming, which I use in many other workflows.

This section contains my core org-mode configuration. There may be additional configuration in subsequent sections (e.g., registering languages with [[http://orgmode.org/worg/org-contrib/babel/][Babel]]).

#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind (("C-c l"   . org-store-link)
           ("C-c RET" . org-open-at-point))

    :init
    (progn
      (setq
       org-hide-leading-stars t
       org-fast-tag-selection-single-key 'expert

       org-default-notes-file "~/notes.org"

       ;; Allow org-mode to refile deeper in the tree
       org-refile-targets '((nil :maxlevel . 2))
       org-refile-use-outline-path t
       org-outline-path-complete-in-steps nil

       ;; Log all my notes, clock time, etc. related to an item into a
       ;; drawer named LOGBOOK, so it can be collapsed and doesn't clutter
       ;; up the display.
       org-log-into-drawer "LOGBOOK")

      (add-to-list 'auto-mode-alist
                   '("\\.org\\'" . (lambda ()
                                     (org-mode)
                                     (visual-line-mode)))))
    :config
    (progn
      (pg-util-diminish-major org-mode "")
      ;; TODO: Is this necessary?
      (add-hook 'org-mode-hook 'turn-on-font-lock)))
#+END_SRC

*** Agenda

A few of the variables configured here really live in =org.el=, but they're relevant to org-mode-as-personal-organizer, which is what =org-agenda= is about anyway.

=org-agenda-custom-commands= controls additional default views I might want on the agenda. I'm cargo-culting much of this, mostly from [[http://newartisans.com/2007/08/using-org-mode-as-a-day-planner/][John Wiegley's seminal GTD configuration]] (where I got a lot of the rest of it, too).


#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :bind (("C-c a" . org-agenda)
           :map org-agenda-mode-map
           ("C-n" . next-line)
           ("C-p" . previous-line))

    :init
    (setq org-agenda-files '("~/todo.org"
                             "~/todo-personal.org")
          org-agenda-ndays 7
          org-deadline-warning-days 14
          org-agenda-show-all-dates t
          org-agenda-skip-deadline-if-done t
          org-agenda-skip-scheduled-if-done t
          org-agenda-start-on-weekday nil
          org-reverse-note-order t

          ;; Control how teh Agenda view sorts tasks
          org-agenda-sorting-strategy
          '((agenda
             habit-down
             priority-down
             alpha-up
             time-up
             category-keep)
            (todo
             priority-down
             category-keep)
            (tags
             priority-down
             category-keep)
            (search category-keep))


          org-agenda-custom-commands
          '(("b" "Backlog items" todo "BACKLOG")
            ("a" "Agenda" agenda ""
             ((org-agenda-skip-function
               (lambda nil
                 (org-agenda-skip-entry-if 'todo '("BACKLOG"))))
              (org-agenda-ndays 7)))
            ("A" "Agenda (with backlog)" agenda ""
             ((org-agenda-skip-function
               (lambda nil
                 (org-agenda-skip-entry-if 'notregexp "\\=.*\\[#A\\]")))
              (org-agenda-ndays 1)
              (org-agenda-overriding-header "Today's Priority #A tasks: ")))
            ("w" todo "WAITING" nil)
            ("W" agenda ""
             ((org-agenda-ndays 21)))

            ("u" alltodo ""
             ((org-agenda-skip-function
               (lambda nil
                 (org-agenda-skip-entry-if 'scheduled
                                           'deadline
                                           'regexp "\n]+>")))
              (org-agenda-overriding-header "Unscheduled TODO entries: ")))))

    :config
    (progn
      (pg-util-diminish-major org-agenda-mode "")))
#+END_SRC

*** Contacts

#+BEGIN_SRC emacs-lisp
  (use-package org-contacts
    :bind (("C-c ?" . org-contacts)
           ("s-/"   . org-contacts))

    :init
    (setq org-contacts-files "~/contacts.org"
          org-contacts-icon-use-gravatar nil))
#+END_SRC

*** Capture

Configuration for [[http://orgmode.org/manual/Capture.html][org-capture]] (formerly =org-remember=).

#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :bind ("s-r" . org-capture)

    :init
    (setq org-capture-templates
          `(("t" "TODO" entry (file+headline "~/todo.org" "Tasks")
             "* TODO %?\n  %u" :prepend t)
            ("T" "TODO (personal)" entry (file+headline
                                          "~/todo-personal.org" "Tasks")
             "* TODO %?\n  %u" :prepend t)
            ("n" "Notes" entry (file+headline "~/notes.org" "Notes")
             "* %u %?" :prepend t)
            ("c" "Contacts" entry (file+headline "~/contacts.org" "New Contacts")
             ,(concat "* %(org-contacts-template-name)\n"
                      ":PROPERTIES:\n"
                      ":EMAIL: %(org-contacts-template-email)\n"
                      ":END:\n")))))
#+END_SRC

*** Indent

#+BEGIN_SRC emacs-lisp
  (use-package org-indent :diminish org-indent-mode)
#+END_SRC




** Text processing

*** Plain Text (=.txt=)

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist
               '("\\.txt$" . (lambda ()
                               (visual-line-mode)
                               (flyspell-mode))))

  (pg-ibuffer '("default" (("text" (or
                                    (mode . text-mode)
                                    (mode . fundamental-mode)
                                    (mode . visual-line-mode))))))

#+END_SRC



*** TeX/LaTeX

You will obviously need TeX/LaTeX installed on your machine for this to be valuable. (And =texbin= will need to be in =exec-path=. How that happens is platform-specific

Enable previewing of LaTeX files.

#+BEGIN_SRC emacs-lisp
(use-package preview-latex)
#+END_SRC

Make =ibuffer= TeX-aware.

#+BEGIN_SRC emacs-lisp
  (pg-ibuffer '("default" (("TeX" (or
                                   (mode . tex-mode)
                                   (mode . latex-mode))))))
#+END_SRC


*** reStructuredText (=.rst=)

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist
               '("\\.rst$" . (lambda ()
                               (rst-mode)
                               (visual-line-mode)
                               (flyspell-mode))))

  (pg-ibuffer '("default" (("ReST" (mode . rst-mode)))))
#+END_SRC

*** XML and HTML

[[http://www.thaiopensource.com/nxml-mode/][nXML mode]] is marvelous. I use it to edit XML. I used to use it for HTML, too, but now I prefer =sgml-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package nxml-mode
    :mode (("\\.xml$" . nxml-mode))
    :config
    (pg-ibuffer '("default" (("XML" (mode . nxml-mode))))))



  (use-package sgml-mode
    :mode (("\\.html$" . html-mode))
    :config
    (pg-ibuffer '("default" (("HTML" (mode . sgml-mode))))))
#+END_SRC


*** JSON

#+BEGIN_SRC emacs-lisp
  (use-package json-mode :ensure t)
#+END_SRC

*** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md$" . markdown-mode))
    :config
    (progn
      (add-hook 'markdown-mode-hook 'visual-line-mode)))
#+END_SRC



** Programming and Software Development

*** Documentation

**** Man (=man-file=)

For whenever you want to view a =troff='ed file without installing it into the Man DB.

#+BEGIN_SRC emacs-lisp
  (defun pg-man-file (file)
    "Directly view a man page file that isn't in the man hierarchy."
    (interactive "fFile: ")
    (man (expand-file-name file)))
  (defalias 'man-file 'pg-man-file)
#+END_SRC

**** Documentation at point (=eldoc=)

Specific languages have their own documentation facilities, but =eldoc= provides documentation for many languages.

That doesn't mean I want it in the mode line, though. :)

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :diminish eldoc-mode)
#+END_SRC

*** Shells

Use [[https://github.com/pgroce/emacs-pkgs/blob/master/pg-sh.org][pg-sh]] to make using shells a little more pleasant.

#+BEGIN_SRC emacs-lisp
  (use-package pg-sh
    :ensure t
    :bind (("s-s" . pg-sh)
           ("s-t" . pg-sh-ssh)))
#+END_SRC

*** Compilation buffers

Tweak Emacs' compilation support to be more needs-suiting.

#+BEGIN_SRC emacs-lisp
  ;;; Let compilation buffers show colors where possible
  (use-package compile
    :init
    (progn
      ;; If I click on an error in =*compilation*= and the file is
      ;; already open in a frame, don't re-open it in a new frame.
      (setq display-buffer-reuse-frames t)
      ;; Cycle through compilation buffer-naming strategies (currently
      ;; the default‚Äìreuse =*compilation*= everywhere‚Äìand creating one
      ;; compile buffer per buffer in which =compile= was invoked.
      (use-package pg-compile-buffers :ensure t)
      ;; Let compilation buffers show colors where possible
      (add-hook 'compilation-filter-hook
                (lambda ()
                  (require 'ansi-color)
                  (toggle-read-only)
                  (ansi-color-apply-on-region compilation-filter-start (point))
                  (toggle-read-only)))))
#+END_SRC

*** Debugging

Some tweaks for the debugger.

#+begin_src emacs-lisp
  (use-package gud
    :ensure t
    :config
    (setq gdb-many-windows t
          gud-gdb-command-name "gdb --annotate=1"))
#+end_src

*** Auto-completion (=company=)

[[http://company-mode.github.io/][Company mode]] is great. Mostly it's used by other things, so I don't have to configure or enable it, just make sure it's available. (I don't like seeing take up space in the modeline, though, so diminish it to nothing.)

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :commands company-mode
    :diminish "")
#+END_SRC

*** Version control (=magit=)

Configure magit, the best Git UI ever.

#+BEGIN_SRC emacs-lisp
  (use-package magit :ensure t
    :config
      (pg-ibuffer '("default" (("magit" (mode . magit-mode))))))
#+END_SRC

*** Search

**** =ag=

[[https://github.com/ggreer/the_silver_searcher][The Silver Searcher]] (command name: =ag=) is a text search tool optimized for source code and software projects.

You'll also need to have The Silver Searcher installed for this to run.

#+BEGIN_SRC emacs-lisp
  (if (= 0 (call-process "which" nil nil nil "ag"))
      (use-package ag
        :ensure t
        :config (use-package helm-ag :defer t :ensure t))
    (message "Pro-tip: Install the Silver Searcher <https://github.com/ggreer/the_silver_searcher> for a better code search experience."))
#+END_SRC

**** =re-builder=

[[http://www.masteringemacs.org/articles/2011/04/12/re-builder-interactive-regexp-builder/][re-builder]] is a visual way to verify that you're writing the right regex. I use it whenever I'm building a complicated regular expression.

I set the default output syntax for re-builder to =string= instead of =read= so I don't have to backslash-escape every damn thing.

#+begin_src emacs-lisp
  (use-package re-builder
    :ensure t
    :config (setq reb-re-syntax 'string))
#+end_src


*** Semantic editing (=smartparens=)

[[https://github.com/Fuco1/smartparens][Semantic editing]] for lisp and other text formats structured with matching delimiters. (They actually use the Github wiki for documentation.)

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :config (progn
              (sp-use-smartparens-bindings)
              (smartparens-global-strict-mode 1)))
#+END_SRC




*** Managing projects (=projectile=)

The killer feature that made me first use [[https://github.com/bbatsov/projectile][Projectile]] was finding files in Java projects, but now I think it's best feature is switching quickly between different contexts. It helps you find files, obviously; it keeps track of project buffers so you can quickly kill them all off or search through them; and it gives you an anchor from which you can start subprocesses (e.g., shells).

Note the use of =pg-sh= to create a shell at the top level of the project directory.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :init
    (progn
      (setq projectile-enable-caching t)
      ;; projectile native indexing is slower, but more reliable imo
      (setq projectile-indexing-method 'native))
    :config
    (progn
      (projectile-global-mode 1)

      (use-package helm-projectile
        :ensure t
        :init (setq projectile-switch-project-action 'helm-projectile))
      (helm-projectile-on)

      (defun pg-projectile-shell-in-project ()
        (interactive)
        (pg-sh (projectile-project-name) (projectile-project-root)))

      (bind-key "1" #'pg-projectile-shell-in-project projectile-command-map)


      (defun pg-projectile-eshell-in-project ()
        (interactive)
        (helm-projectile-switch-to-eshell (projectile-project-root)))

      (bind-key "`" #'pg-projectile-eshell-in-project projectile-command-map)))
#+END_SRC


*** Virtualization
**** Vagrant

[[https://www.vagrantup.com/][Vagrant]] is cool. =vagrant-tramp= provides a TRAMP method for editing files in a Vagrant machine and lets you log in to Vagrant machines from Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package vagrant-tramp
    :ensure t)
#+END_SRC

**** Docker
[[https://www.docker.com/][Docker]] is cool. [[https://github.com/spotify/dockerfile-mode][dockerfile-mode]] provides syntax highlighting for Docker files. [[https://github.com/Silex/docker.el][docker.el]] lets you manage Docker containers from Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :ensure t
    :mode "Dockerfile\\'")
  (use-package docker
    :ensure t
    :bind-keymap ("C-c d" . docker-command-map))
#+END_SRC


*** Languages
**** Lisps

Show matching parentheses.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

***** Emacs Lisp

Turn on =auto-completion=, =eldoc= and +=paredit=+ =smartparens=.

#+BEGIN_SRC emacs-lisp
  (use-package lisp-mode
    :init
    (progn
      (add-hook
       'emacs-lisp-mode-hook
       '(lambda ()
          (company-mode)
          (eldoc-mode)
          (smartparens-mode)))
      (pg-util-diminish-major emacs-lisp-mode "elisp")))
#+END_SRC

**** Python
Python configuration is a little tricky; full functionality  depends on a lot of external tools, many of which are written in Python, so can (should) be installed in a virtual environment rather than in one canonical place in the system.

To get the full benefit of this configuration, you'll want to install the following in your virtualenv:

#+BEGIN_SRC sh :tangle no
  pip install jedi
  pip install flake8
#+END_SRC

(There will be additional requirement associated with Elpy, below.

#+BEGIN_SRC emacs-lisp
  (use-package py-autopep8 :ensure t)
  (use-package pylint :ensure t)
  (use-package pyvenv :ensure t)

  (use-package python
    :init
    (progn
      ;;; Ignore byte-compiled files when doing filename completion
      (pg-util-list-add-unique-var 'completion-ignored-extensions
                                   '(".pyc" ".pyo"))

      ;;; Treat PSP files as regular HTML, not Python
      (add-to-list 'auto-mode-alist '("\\.psp$" . html-mode))

      (pg-util-diminish-major python-mode "py")
      (setq python-fill-docstring-style 'symmetric)))
#+END_SRC

***** Elpy

[[https://github.com/jorgenschaefer/elpy][Elpy]] provides IDE feature with the help of a subprocess running Python. For full benefit, install the following modules into your environment (in addition to those in [[Python]] above.

#+BEGIN_SRC sh :tangle no
  pip install importmagic
  pip install autopep8
  pip install yapf
#+END_SRC

Remove =yasnippet= from elpy-modules because screw =yasnippet=.

#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :commands elpy-enable
    :init
    (setq elpy-rpc-backend "jedi")
    :config
    (progn
      (remove-hook 'elpy-modules 'elpy-module-yasnippet)))

#+END_SRC

Elpy is complicated and has, in the past, been kind of janky. If it's undesirable to use Elpy, set =pg-enable-elpy= to =nil= and Emacs will just use the normal =python-mode=.

I'd love to wrap this in a =use-package= stanza, but so far that's defeated me.

#+BEGIN_SRC emacs-lisp
  (setq pg--elpy-enabled nil)

  (defcustom pg-enable-elpy t
    "Flag set when elpy should be used in this configuration.")

  (defun pg-python-mode ()
    "If it's desired and hasn't been already, call `elpy-enable'
  before running python-mode."


    (when (and pg-enable-elpy
               (not pg--elpy-enabled))
      (elpy-enable))
    (python-mode))

  ;;; python-mode is in the core image, so root out baked-in references
  ;;; to python-mode. This is probably unnecessary, but better safe than
  ;;; sorry.
  (setq auto-mode-alist
        (--filter (not (equal "\\.py\\'" (car it))) auto-mode-alist))
  (setq interpreter-mode-alist
        (--filter (not (equal "python[0-9.]*" (car it))) interpreter-mode-alist))

  (setq auto-mode-alist
        (pg-util-update-auto-mode-alist "\\.py$" 'pg-python-mode))

  (setq interpreter-mode-alist
        (pg-util-update-auto-mode-alist
         "\\.py$"
         'pg-python-mode
         interpreter-mode-alist))
#+end_src

**** Javascript

Use [[https://github.com/mooz/js2-mode][js2-mode]] rather than the built-in =js-mode= for JavaScript.

I learned my =next-error= and =previous-error= keybinds from Elpy, so use those.

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :mode "\\.js$"
    :interpreter "node"
    :bind (("C-c n" . next-error)
           ("C-c p" . previous-error))
    :config (pg-util-diminish-major js2-mode "js2"))
#+END_SRC


* Customizing platforms

** OS X (=darwin=)

Everything in this section goes in =darwin.el= and gets executed only on OS X systems.

This config pretty much assumes you run [[https://brew.sh/][Homebrew]].

*** General customizations

I don't wrap these in =pg-terminal-ns= because they're OS X-specific, not strictly ns-specific. (I dunno, maybe I'll run this on Gnustep someday.)

**** Use =mdfind= as =locate=

On many Unix systems, the =locate= command will run the system =locate= command to search a pre-compiled file database for a file. On OS X, the =mdfind= command (which searches Spotlight) has sufficiently similar syntax that it can be used instead.

#+BEGIN_SRC emacs-lisp
  (setq locate-command "mdfind")
#+END_SRC

**** GNU =ls=

OS X =ls= is not GNU, so use =gls= (the version of =ls= from GNU Coreutils) on the Mac instead of =/bin/ls=, because the GNU version supports dired better. (Make sure it's installed via MacPorts, Homebrew, etc.)

#+BEGIN_SRC emacs-lisp
  (if (= 0 (call-process "which" nil nil nil "gls"))
      (setq insert-directory-program "gls")
    (message "Pro-tip: Install 'gls' ('brew install coreutils') for a better dired experience."))
#+END_SRC


**** Set =TMPDIR= to something short

OS X has horrible long temporary directory paths that sometimes exceed the lengths some applications are expecting. Just use =/tmp=

#+BEGIN_SRC emacs-lisp
  (setenv "TMPDIR" "/tmp")
#+END_SRC


*** =ns= terminal configuration


**** Decontaminate =super= keybindings

The =ns= Emacs port adds a number of keybindings to =super= in an attempt to make Emacs feel like a NeXTStep/Mac application.

I'd rather use the Emacs style of interaction, because I've learned it already and because I can find better uses for =super=. (Most of these bindings are harmless, but a few, like =s-q= running =save-buffers-kill-emacs=, are infuriating.)

Furthermore, I like to put my own bindings on =super=.

Therefore, kill it all with fire.

#+BEGIN_SRC emacs-lisp :tangle darwin.el
  (pg-terminal-ns
   (global-unset-key (kbd "M-s-h"))
   (global-unset-key (kbd "s-,"))
   (global-unset-key (kbd "s-'"))
   (global-unset-key (kbd "s-`"))
   (global-unset-key (kbd "s-~"))
   (global-unset-key (kbd "s--"))
   (global-unset-key (kbd "s-:"))
   (global-unset-key (kbd "s-?"))
   (global-unset-key (kbd "s-^"))
   (global-unset-key (kbd "s-&"))
   (global-unset-key (kbd "s-C"))
   (global-unset-key (kbd "s-D"))
   (global-unset-key (kbd "s-E"))
   (global-unset-key (kbd "s-L"))
   (global-unset-key (kbd "s-M"))
   (global-unset-key (kbd "s-S"))
   (global-unset-key (kbd "s-a"))
   (global-unset-key (kbd "s-c"))
   (global-unset-key (kbd "s-d"))
   (global-unset-key (kbd "s-e"))
   (global-unset-key (kbd "s-f"))
   (global-unset-key (kbd "s-g"))
   (global-unset-key (kbd "s-h"))
   (global-unset-key (kbd "s-H"))
   (global-unset-key (kbd "s-j"))
   (global-unset-key (kbd "s-k"))
   (global-unset-key (kbd "s-l"))
   (global-unset-key (kbd "s-m"))
   (global-unset-key (kbd "s-n"))
   (global-unset-key (kbd "s-o"))
   (global-unset-key (kbd "s-p"))
   (global-unset-key (kbd "s-q"))
   (global-unset-key (kbd "s-s"))
   (global-unset-key (kbd "s-t"))
   (global-unset-key (kbd "s-u"))
   (global-unset-key (kbd "s-v"))
   (global-unset-key (kbd "s-w"))
   (global-unset-key (kbd "s-x"))
   (global-unset-key (kbd "s-y"))
   (global-unset-key (kbd "s-z"))
   (global-unset-key (kbd "s-|"))
   (global-unset-key (kbd "s-<kp-bar>"))
   (global-unset-key (kbd "s-<right>"))
   (global-unset-key (kbd "s-<left>")))
#+END_SRC

**** GUI setup

Use the navigation functions defined in the general configuration in OS X GUI Emacs.

#+BEGIN_SRC emacs-lisp :tangle darwin.el
  (pg-terminal-ns
   (pg-clean-frames)
   (pg-navigate-frames)
   (pg-navigate-windows))
#+END_SRC

**** Keyboard/mouse setup

***** Modifier keys

Make left command =meta=, and make right alt and right command =super=. (I should experiment with right command being =hyper=, but haven't so far.)

#+BEGIN_SRC emacs-lisp :tangle darwin.el

  (pg-terminal-ns
   (setq ns-right-control-modifier 'super)
   (setq ns-option-modifier  nil)
   (setq ns-right-option-modifier  'super)
   (setq ns-command-modifier 'meta))
#+END_SRC

***** Restore mouse wheel

The mouse wheel setup will get clobbered when using a daemon, due to the different order in which things start up. This restores it.

#+begin_src emacs-lisp :tangle darwin.el
  (pg-terminal-ns
   (when (daemonp)
     (progn
       (setq-default mouse-wheel-down-event 'wheel-up
                     mouse-wheel-up-event 'wheel-down)
       (global-set-key (kbd "<wheel-up>") 'mwheel-scroll)
       (global-set-key (kbd "<wheel-down>") 'mwheel-scroll))))
#+end_src




* Integrations with external tools

** =pdf-tools=

#+BEGIN_SRC emacs-lisp :tangle darwin.el
  (if (= 0 (call-process "which" nil nil nil "epdfinfo"))
      (use-package pdf-tools :ensure t)
    (message "Pro-tip: Install pdf-tools (e.g., 'brew install pdf-tools') for better PDF experience."))
#+END_SRC


** LaTeX

#+BEGIN_SRC emacs-lisp :tangle darwin.el
  (if (file-exists-p "/Library/TeX/texbin")
      (pg-shell-path-append "/Library/Tex/texbin")
    (message "Pro-tip: Install Tex (or MacTeX) for a better LaTeX experience"))
#+END_SRC

* Wrapup

The configuration has yet to run =scratch.el=, so this isn't /final/ final, but in general this section is the last word.

I normally start the Emacs server. (But don't complain if it's already running.)

#+BEGIN_SRC emacs-lisp
  (require 'warnings)
  (add-to-list 'warning-suppress-types '(server))
  (server-start)
#+END_SRC

Open =scratch.el=, because I always seem to be fiddling with it. Nuke the default scratch buffer, it's silly. (I ran into a problem where it was already dead by this time. I haven't looked into it yet, so in the meantime, just ignore =kill-buffer= if it complains for some reason.)

#+BEGIN_SRC emacs-lisp
  (find-file (expand-file-name "scratch.el" ecfw-config-dir))
  (condition-case nil (kill-buffer "*scratch*") nil)
#+END_SRC

Finally, open =todo.org= and start the day!

#+BEGIN_SRC emacs-lisp
  (find-file (expand-file-name "~/todo.org"))
#+END_SRC
